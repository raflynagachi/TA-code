    def embed_message(self, block, encoded_data):
        indexes = [((5, 0), (3, 3)), ((2, 2), (1, 4)),
                   ((0, 4), (3, 2)), ((4, 1), (4, 2))]
        for si, ei in indexes:
            if len(encoded_data) == 0:
                break

            # Swapping DCT
            if block[si[0]][si[1]] == block[ei[0]][ei[1]] and encoded_data[0] == "1":
                block[si[0]][si[1]] += 1.5
            if (encoded_data[0] == "0" and block[si[0]][si[1]] < block[ei[0]][ei[1]]) or (encoded_data[0] == "1" and block[si[0]][si[1]] >= block[ei[0]][ei[1]]):
                block[si[0]][si[1]], block[ei[0]][ei[1]
                                                  ] = block[ei[0]][ei[1]], block[si[0]][si[1]]
            encoded_data = encoded_data[1:]

        return encoded_data

    def extract_message(self, block, message, max_char):
        indexes = [((5, 0), (3, 3)), ((2, 2), (1, 4)),
                   ((0, 4), (3, 2)), ((4, 1), (4, 2))]
        i = 0 if message == "" else len(message)
        for si, ei in indexes:
            if max_char != 0 and max_char == len(message):
                break

            # Swapping DCT
            encode_bit = "0" if block[si[0]][si[1]
                                             ] >= block[ei[0]][ei[1]] else "1"
            message += encode_bit

            if i >= 31 and max_char == 0:
                print("message length: ", message[:32])
                max_char = helper.binary_to_int(message[:32])
                message = message[32:]
            i += 1
        return message, max_char